# (C) 2018 University of Bristol. See License.txt

NUM_ROWS = 10

from Compiler.types import sint, regint, Array, MemValue
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

NUM_COLS = 10
DIMENSION_WEIGHT = 10
DECIMAL_PRECISION = 20

# Shift 20 places to get from float representation to int representation
FP_FACTOR = 20
sfix.set_precision(FP_FACTOR, 40)
cfix.set_precision(FP_FACTOR, 40)


# Local computation of weight vector.
def admm_local(XXinv, Xy, u, z, rho, l):
	z_u = sfixArray(len(z))
	@for_range(len(z))
	def loop_body(i):
		z_u[i] = rho * (z[i] - u[i])

	second_term = add_matrices(Xy, z_u)
	w = multiply_matrices(XXinv, second_term)
	return w

def soft_threshold(th, v):
	if v > th:
		return v - th
	if v < -1 * th:
		return v + th

	return 0 
	"""
	if_then(v > th)
	return v - th
	if_then(v < -1*th)
	return v + th
	else_then()
	return 0
	end_if()
	"""

def soft_threshold_vec(th, vec):
    vec_new = sfixArray(len(vec))
    @for_range(len(vec))
    def loop_body(i):
    	mem_th = MemFix(sfix(0))
    	vec_th = MemFix(sfix(0))
    	mem_th.write(sfix(th))
    	vec_th.write(sfix(vec[i]))
    	print(type(mem_th.read()))
    	vec_new[i] = soft_threshold(mem_th.read(), vec_th.read())
    
    return vec_new

def admm_coordinate(w_list, u_list, z, rho, l):
    d = NUM_COLS
    nparties = MAX_NUM_CLIENTS
    w_avg = sfixArray(NUM_COLS)
    u_avg = sfixArray(NUM_COLS)
    @for_range(d)
    def loop_body(i):
    	w_avg[i] = sfix(0)
    	u_avg[i] = sfix(0)

    # Assume u_list and w_list are same length.
    
    @for_range(nparties)
    def loop_body(i):
    	w = get_ith_matrix(w_list, i, NUM_COLS)
    	u = get_ith_matrix(u_list, i, NUM_COLS)
    	new_w_avg = add_matrices(w_avg, w)
    	new_u_avg = add_matrices(u_avg, u)
    	copy_ith_matrix(w_avg, new_w_avg, 0, NUM_COLS)
    	copy_ith_matrix(u_avg, new_u_avg, 0, NUM_COLS)


	@for_range(len(w_list))
	def loop_body(i):
		w_avg[i] = w_avg[i] / len(w_list)
		u_avg[i] = u_avg[i] / len(u_list)
	   	

    # threshold
    th = sfix(l / (rho * nparties))
    
    z_new = soft_threshold_vec(th, add_matrices(w_avg, u_avg))
    
    u_list_new = sfixArray(len(u_list))
    @for_range(nparties)
    def loop_body(i):
    	u_i = get_ith_matrix(u_list, i, NUM_COLS)
    	w_i = get_ith_matrix(w_list, i, NUM_COLS)
    	@for_range(len(z_new))
    	def loop_body(j):
    		z_new[j] = - 1 * z_new[j]

    	intermediate_vec = add_matrices(u_i, w_i)
    	sum_vec = add_matrices(intermediate_vec, z_new)
    	copy_ith_matrix(u_list, sum_vec, i, NUM_COLS)
    	#u_list_new[i] = (u_list[i] + w_list[i] - z_new)

    return (u_list_new, z_new)



def get_new_w(XXinv_cache, Xy_cache, u_list, z, rho, l):
	nparties = MAX_NUM_CLIENTS
	w_list = sfixArray(nparties)
	@for_range(nparties)
	def loop_body(i):
		XXinv = get_ith_matrix(XXinv_cache, i, NUM_ROWS*NUM_COLS)
		Xy = get_ith_matrix(Xy_cache, i, NUM_COLS)
		u = get_ith_matrix(u_list, i, NUM_COLS)
		w_new = admm_local(XXinv, Xy, u, z, rho, l)
		copy_ith_matrix(w_list, w_new, i, NUM_COLS)
	return w_list

def admm(XXinv_cache, Xy_cache, admm_iter, rho, l):
	nparties = MAX_NUM_CLIENTS
	# Init all the lists, set everything to 0
	w_list = sfixArray(nparties * NUM_COLS)
	u_list = sfixArray(nparties * NUM_COLS)
	z = sfixArray(NUM_COLS)
	@for_range(len(w_list))
	def loop_body(i):
		w_list[i] = sfix(0)
		u_list[i] = sfix(0)
	@for_range(len(z))
	def loop_body(i):
		z[i] = sfix(0)

	@for_range(admm_iter)
	def loop_body(i):
		XXinv = get_ith_matrix(XXinv_cache, i, NUM_ROWS * NUM_COLS)
		Xy = get_ith_matrix(Xy_cache, i, NUM_COLS)
		u = get_ith_matrix(u_list, i, NUM_COLS)
		new_w_list = get_new_w(XXinv_cache, Xy_cache, u, z, rho, l)	
		new_u_list, new_z = admm_coordinate(new_w_list, u_list, z, rho, l)
		@for_range(len(u_list))
		def loop_body(j):
			w_list[j] = new_w_list[j]
			u_list[j] = new_u_list[j]
		@for_range(len(new_z))
		def loop_body(i):
			z[i] = new_z[i]

	return w_list


def get_ith_matrix(lst, index, step_size):
	result = sfixArray(NUM_ROWS * NUM_COLS)
	@for_range(NUM_ROWS * NUM_COLS)
	def loop_body(i):
		result[i] = lst[index * step_size + i]
	return result

def copy_ith_matrix(lst, lst_to_copy, index, step_size):
	@for_range(len(lst_to_copy))
	def loop_body(i):
		lst[index * step_size + i] = lst_to_copy[i]


def add_matrices(left_matrix, right_matrix):
	result_matrix = sfixArray(NUM_ROWS * NUM_COLS)
	@for_range(NUM_ROWS * NUM_COLS)
	def range_body(i):
		result_matrix[i] = sfix(0)
	@for_range(NUM_ROWS)
	def range_body(i):
		@for_range(NUM_COLS)
		def range_body(j):
			result_matrix[i * NUM_COLS + j] = left_matrix[i * NUM_COLS + j] + right_matrix[i * NUM_COLS + j]
	return result_matrix


def multiply_matrices(left_matrix, right_matrix):
  result_matrix = sfixArray(NUM_ROWS * NUM_COLS)
  @for_range(NUM_ROWS * NUM_COLS)
  def range_body(i):
    result_matrix[i] = sfix(0)
  @for_range(NUM_ROWS)
  def range_body(i):
    @for_range(NUM_COLS)
    def range_body(j):
      @for_range(NUM_COLS)
      def range_body(k):
        result_matrix[i * NUM_COLS + j] += left_matrix[i * NUM_COLS + k].reveal() * right_matrix[k * NUM_COLS + j].reveal()
  return result_matrix
  


def send_weights_to_clients(sockets, number_clients, weights):
  rnd_from_triple = sint.get_random_triple()[0]
  @for_range(number_clients)
  def loop_body(i):
    @for_range(NUM_COLS)
    def loop_body(j):
      auth_result = weights[j] * rnd_from_triple
      sint.write_shares_to_socket(sockets[i], [weights[j], rnd_from_triple, auth_result])





MAX_NUM_CLIENTS = 2
PORTNUM = 14000
rho = 0.01
l = 0.008
admm_iter = 10

def accept_client_input():
	client_socket_id = regint()
	acceptclientconnection(client_socket_id, PORTNUM)
	print_ln("Received Client Input!")
	client_inputs = sint.receive_from_client(1 + NUM_ROWS * NUM_COLS + DIMENSION_WEIGHT, client_socket_id)
	finish = client_inputs[0]
	XX_inv = sfixArray(NUM_ROWS * NUM_COLS)
	print_ln("%s", "Getting input")
	for i in range(1, NUM_ROWS * NUM_COLS + 1):
		x = sfix(client_inputs[i])
		XX_inv[i - 1] = x
		print_ln("%s", x.reveal())

	Xy = sfixArray(NUM_ROWS)
	for i in range(NUM_ROWS):
		x = sfix(client_inputs[i + 1 + NUM_ROWS * NUM_COLS])
		Xy[i] = x

	return XX_inv, Xy, client_socket_id, finish

def main():
	listen(PORTNUM)
	print_ln('Listening for client connections on base port %s', PORTNUM)
	@do_while
	def loop():
		XXinv_cache = sfixArray(MAX_NUM_CLIENTS * NUM_ROWS * NUM_COLS)
		Xy_cache = sfixArray(MAX_NUM_CLIENTS * NUM_ROWS)
		client_sockets = Array(MAX_NUM_CLIENTS, regint)
		number_clients = MemValue(regint(0))
		XXinv_index = MemValue(regint(0))
		Xy_index = MemValue(regint(0))
		@for_range(MAX_NUM_CLIENTS)
		def loop_body(i):
			XX_inv, Xy, client_sockets[i], finish = accept_client_input()
			@for_range(NUM_ROWS * NUM_COLS)
			def loop_body(k):
				XXinv_cache[XXinv_index] = XX_inv[i]
				XXinv_index.write(XXinv_index + 1)
			@for_range(NUM_ROWS)
			def loop_body(k):
				Xy_cache[Xy_index] = Xy[i]
				Xy_index.write(Xy_index + 1)

			number_clients.write(number_clients+1)
		print_ln("%s", "Am I here?")
		weights = admm(XXinv_cache, Xy_cache, admm_iter, rho, l)
		new_weights = Array(len(weights), sint)
		print_ln("%s", "Printing weights......")
		@for_range(len(weights))
		def loop_body(i):
			new_weights[i] = weights[i].v
			print_ln("%s", weights[i].reveal())

		send_weights_to_clients(client_sockets, MAX_NUM_CLIENTS, new_weights)
		return True

main()